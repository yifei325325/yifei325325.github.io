<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-第四章：数据库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/25/第四章：数据库/" class="article-date">
  <time datetime="2018-09-25T03:40:53.000Z" itemprop="datePublished">2018-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/flask-教程/">flask 教程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/25/第四章：数据库/">第四章：数据库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文翻译自 <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iv-database" target="_blank" rel="noopener">The Flask Mega-Tutorial Part IV: Database</a></p>
<p>在Flask Mega-Tutorial系列的第四部分，我将告诉你如何使用<em>数据库</em>。</p>
<p>本章的主题是重中之重！大多数应用都需要持久化存储数据，并高效地执行的增删查改的操作，<em>数据库</em>为此而生。</p>
<h2 id="Flask中的数据库"><a href="#Flask中的数据库" class="headerlink" title="Flask中的数据库"></a>Flask中的数据库</h2><p>Flask本身不支持数据库，相信你已经听说过了。 正如表单那样，这也是Flask有意为之。对使用的数据库插件自由选择，岂不是比被迫适应其中之一，更让人拥有主动权吗？</p>
<p>绝大多数的数据库都提供了Python客户端包，它们之中的大部分都被封装成Flask插件以便更好地和Flask应用结合。数据库被划分为两大类，遵循<em>关系</em>模型的一类是关系数据库，另外的则是非关系数据库，简称<em>NoSQL</em>，表现在它们不支持流行的关系查询语言<a href="https://en.wikipedia.org/wiki/SQL" target="_blank" rel="noopener">SQL</a>（译者注：部分人也宣称NoSQL代表不仅仅只是SQL）。虽然两类数据库都是伟大的产品，但我认为关系数据库更适合具有结构化数据的应用程序，例如用户列表，用户动态等，而NoSQL数据库往往更适合非结构化数据。 本应用可以像大多数其他应用一样，使用任何一种类型的数据库来实现，但是出于上述原因，我将使用关系数据库。<br>在<a href="https://yifei325325.github.io/2018/09/25/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AWeb%E8%A1%A8%E5%8D%95/" target="_blank" rel="noopener">第三章</a>中，我向你展示了第一个Flask扩展，在本章中，我还要用到两个。 第一个是<a href="http://packages.python.org/Flask-SQLAlchemy" target="_blank" rel="noopener">Flask-SQLAlchemy</a>，这个插件为流行的<a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy</a>包做了一层封装以便在Flask中调用更方便，类似<em>SQLAlchemy</em>这样的包叫做<a href="http://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank" rel="noopener">Object Relational Mapper</a>，简称ORM。 ORM允许应用程序使用高级实体（如类，对象和方法）而不是表和SQL来管理数据库。 ORM的工作就是将高级操作转换成数据库命令。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/25/第四章：数据库/" data-id="cjmh6hb1h0005lgkxdpabrvn1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flask-教程/">flask 教程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-第三章：Web表单" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/25/第三章：Web表单/" class="article-date">
  <time datetime="2018-09-25T03:31:57.000Z" itemprop="datePublished">2018-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/flask-教程/">flask 教程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/25/第三章：Web表单/">第三章：Web表单</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文翻译自 <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iii-web-forms" target="_blank" rel="noopener">The Flask Mega-Tutorial Part III: Web Forms</a></p>
<p>这是Flask Mega-Tutorial系列的第三部分，我将告诉你如何使用<em>Web表单</em>。</p>
<p>在<a href="https://yifei325325.github.io/2018/09/25/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%A8%A1%E6%9D%BF/" target="_blank" rel="noopener">第二章</a>中我为应用主页创建了一个简单的模板，并使用诸如用户和用户动态的模拟对象。在本章中，我将解决这个应用程序中仍然存在的众多遗漏之一，那就是如何通过Web表单接受用户的输入。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/25/第三章：Web表单/" data-id="cjmh6hb140000lgkxdex52xlk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flask-教程/">flask 教程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-第二章：模板" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/25/第二章：模板/" class="article-date">
  <time datetime="2018-09-25T03:06:02.000Z" itemprop="datePublished">2018-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/flask-教程/">flask 教程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/25/第二章：模板/">第二章：模板</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文翻译自<a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-ii-templates" target="_blank" rel="noopener">The Flask Mega-Tutorial Part II: Templates</a><br>在Flask Mega-Tutorial系列的第二部分中，我将讨论如何使用<em>模板</em>。</p>
<p>学习完<a href="">第一章</a>之后，你已经拥有了一个虽然简单，但是可以成功运行的Web应用，它的文件结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">microblog\</span><br><span class="line">  venv\</span><br><span class="line">  app\</span><br><span class="line">    __init__.py</span><br><span class="line">    routes.py</span><br><span class="line">  microblog.py</span><br></pre></td></tr></table></figure></p>
<p>在终端会话中设置环境变量<code>FLASK_APP=microblog.py</code>，然后执行<code>flask run</code>命令来运行应用。<br>包含这个应用的Web服务启动之后，你可以通过在Web浏览器的地址栏中键入URL<em><a href="http://localhost:5000" target="_blank" rel="noopener">http://localhost:5000</a></em> 来验证。<br>本章将沿用这个应用，在此之上，你将学习如何生成包含复杂结构的诸多动态组件的网页。如果对这个应用和相关开发流程有所遗忘，情回顾<a href="https://yifei325325.github.io/2018/09/25/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AHello-world/" target="_blank" rel="noopener">第一章</a>。</p>
<h2 id="什么是模板？"><a href="#什么是模板？" class="headerlink" title="什么是模板？"></a>什么是模板？</h2><p>我设计的微博应用程序的主页会有一个欢迎用户的标题。虽然目前的应用程序还没有实现用户概念，但这不妨碍我使用一个Python字典来<em>模拟</em>一个用户，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = &#123;&apos;username&apos;:&apos;Miguel&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建模拟对象是一项实用的技术，它可以让你专注于应用程序的一部分，而无需为系统中尚不存在的其他部分分心。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/25/第二章：模板/" data-id="cjmh6hb1f0004lgkxbv1wamxa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flask-教程/">flask 教程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-第一章：Hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/25/第一章：Hello-world/" class="article-date">
  <time datetime="2018-09-25T02:38:45.000Z" itemprop="datePublished">2018-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/flask-教程/">flask 教程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/25/第一章：Hello-world/">第一章：Hello world</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文翻译自<a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world" target="_blank" rel="noopener">The Flask Mega-Tutorial Part I: Hello, World!</a></p>
<p>一趟愉快的学习之旅即将开始，跟随它你将学会用<a href="https://python.org/" target="_blank" rel="noopener">Python</a>和<a href="http://flask.pocoo.org/" target="_blank" rel="noopener">Flask</a>来创建Web应用。上面的视频包含了整个教程的内容预览（译者注：视频见原文）。通过学习本章内容，你将学会如何创建一个Flask项目，并在自己的电脑上运行一个简单的Flask Web应用。</p>
<p>教程中所有的代码示例都托管在GitHub上。虽然直接从GitHub下载代码可以节省写代码的步骤，但是我强烈建议你至少在前几章自己动手书写这些代码。一旦你熟悉了Flask和示例应用，一些繁琐重复的代码就可以直接从GitHub复制了。</p>
<p>在每章的开头，我都将提供三个GitHub的链接来帮助你顺畅地学习本章的内容。点击<strong>Browse</strong>链接会打开GitHub上Microblog项目在本章的对应代码库页面，不会包含之后章节的任何新增代码。而<strong>Zip</strong>链接则提供了这份代码库的zip打包文件的下载地址。如果点击<strong>Diff</strong>链接，打开的将会是本章节的代码变更信息。</p>
<p><em>本章的GitHub链接为: <a href="https://github.com/miguelgrinberg/microblog/tree/v0.1" target="_blank" rel="noopener">Browse</a>, <a href="https://github.com/miguelgrinberg/microblog/archive/v0.1.zip" target="_blank" rel="noopener">Zip</a>, <a href="https://github.com/miguelgrinberg/microblog/compare/v0.0...v0.1" target="_blank" rel="noopener">Diff</a>.</em></p>
<h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h2><p>你说你还没有安装Python？那还等什么！立马安装吧。如果操作系统默认没有提供Python安装包，可以从<a href="http://python.org/download/" target="_blank" rel="noopener">Python官方网站</a>下载。如果你使用Microsoft Windows操作系统并且打算使用WSL或者Cygwin，需要注意，不要在上面使用Windows版本的Python，而要使用类Unix版本，比如从Ubuntu获取（对应WSL）或从Cygwin上获取。</p>
<p>为了验证Python是否正确安装，你可以打开一个终端窗口并输入<code>python3</code>（如果不存在这个命令，那就输入<code>python</code>）。预期的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python 3.5.2 (default, Nov 17 2016, 17:05:23)</span><br><span class="line">[GCC 5.4.0 20160609] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; _</span><br></pre></td></tr></table></figure></p>
<p>Python解释器中，光标不断闪烁，等待着你输入Python语句。在未来的章节中，你可以充分体会到交互式解释器的魅力。至少现在它能够帮你确认Python已经成功安装的事实。可以输入<code>exit()</code>并回车来退出交互式解释器。在Linux和Mac OS X操作系统上，按下快捷键Ctrl-D也可以快速退出交互式解释器。在Windows操作系统上，则是通过按下Ctrl-Z后跟上Enter快捷键来快速退出。</p>
<h2 id="安装Flask"><a href="#安装Flask" class="headerlink" title="安装Flask"></a>安装Flask</h2><p>下一步开始安装Flask，在这之前我要告诉你安装Python三方包的最佳实践。</p>
<p>Python将所有三方包托管到一个公共仓库，任何人都能从这个公共仓库下载并安装所有的三方包。Python将三方包公共仓库命名为<a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">PyPI</a>以表示Python Package Index的缩写(被一些人戏称为”cheese shop”)。从PyPI上安装三方包非常简单，Python专门提供了一个名为<code>pip</code>的工具来解决这个问题（Python2.7中不含<code>pip</code>工具，需要单独安装）。</p>
<p>安装三方包时，使用<code>pip</code>命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install &lt;package-name&gt;</span><br></pre></td></tr></table></figure></p>
<p>有趣的是，这个方法在大多数情况下不适用。假如Python解释器是全局安装的，所有用户都能使用，那么普通用户则没有权限来修改它，因此只能用管理员账户来执行安装操作。即使忽略操作的复杂性，使用这种全局安装的方式会发生什么？<code>pip</code>工具从PyPI上下载三方包并安装到全局Python目录下，即刻起，所有Python脚本都可以访问到这个三方包。想象这样一个场景，你之前用当时的最新版本Flask——0.11版本的Flask开发了一个Web应用，现在Flask已经更新到了0.12版本，你想要使用0.12版本的Flask开发第二个Web应用。但是，如果将Flask从0.11版本升级到0.12版本可能会导致第一个Web应用出现故障。解决这个问题的方法最好不过为旧Web应用安装和使用Flask0.11版本，为新Web应用安装和使用Flask0.12版本。</p>
<p>为了解决维护不同应用程序对应不同版本的问题，Python使用了<em>虚拟环境</em>的概念。 虚拟环境是Python解释器的完整副本。在虚拟环境中安装三方包时只会作用到虚拟环境，全局Python解释器不受影响。 那么，就为每个应用程序安装各自的虚拟环境吧。 虚拟环境还有一个好处，即它们由创建它们的用户所拥有，所以不需要管理员帐户。</p>
<p>我们先创建项目目录，我将这个应用命名为<em>microblog</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir microblog</span><br><span class="line">$ cd microblog</span><br></pre></td></tr></table></figure></p>
<p>如果你正在使用Python3，虚拟环境已经成为内置模块，可以直接通过如下命令来创建它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m venv venv</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>译者注：这个命令不一定能够执行成功，比如译者在Ubuntu16.04环境下执行，提示需要先安装对应的依赖。<code>sudo apt-get install python3-venv</code></p>
</blockquote>
<p>使用这个命令来让Python运行<code>venv</code>包，它会创建一个名为<code>venv</code>的虚拟环境。 命令中的第一个“venv”是Python虚拟环境包的名称，第二个是要用于这个特定环境的虚拟环境名称。 如果你觉得这样很混乱，可以用你自定义的虚拟环境名字替换第二个<code>venv</code>。我习惯在项目目录中创建了名为<code>venv</code>的虚拟环境，所以无论何时<code>cd</code>到一个项目中，都会找到相应的虚拟环境。</p>
<p>请注意，在一些操作系统中，你可能需要在上面的命令中使用<code>python</code>而不是<code>python3</code>。 一些安装规范对Python 2.x版本使用<code>python</code>，对3.x版本使用<code>python3</code>，而另一些则将<code>python</code>映射到3.x版本。</p>
<p>命令执行完成后，当前目录下就会新增一个名为<code>venv</code>的目录来存储这个虚拟环境的相关文件。</p>
<p>如果你使用的Python版本低于3.4（包括2.7版本），则不会默认支持虚拟环境。 对于这些版本的Python，在创建虚拟环境之前，需要下载并安装称为<a href="https://virtualenv.pypa.io/" target="_blank" rel="noopener">virtualenv</a>的第三方工具。 一旦安装了virtualenv，你可以使用以下命令创建一个虚拟环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv venv</span><br></pre></td></tr></table></figure></p>
<p>不管你用什么方法创建虚拟环境，创建完毕之后还需要激活才能够进入这个虚拟环境。 要激活你的全新虚拟环境，需使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ source venv/bin/activate</span><br><span class="line">(venv) $ _</span><br></pre></td></tr></table></figure></p>
<p>如果你使用的是Microsoft Windows命令提示符窗口，则激活命令稍有不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ venv\Scripts\activate</span><br><span class="line">(venv) $ _</span><br></pre></td></tr></table></figure>
<p>激活一个虚拟环境，终端会话的环境配置就会被修改，之后你键入<code>python</code>的时候，实际上是调用的虚拟环境中的Python解释器。 此外，终端提示符也被修改成包含被激活的虚拟环境的名称的格式。这种激活是临时的和私有的，因此在关闭终端窗口时它们将不会保留，也不会影响其他的会话。 那么，当你需要同时打开多个终端窗口来调试不同的应用时，每个终端窗口都可以激活不同的虚拟环境而不会相互影响。</p>
<p>成功创建和激活了虚拟环境之后，你可以安装Flask了，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip install flask</span><br></pre></td></tr></table></figure></p>
<p>想要验证安装是否成功，可以打开Python解释器，并用<em>import</em>语句来导入它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import flask</span><br><span class="line">&gt;&gt;&gt; _</span><br></pre></td></tr></table></figure></p>
<p>如果语句没有报错，那么恭喜你，Flask安装成功了！</p>
<h2 id="“Hello-World”-Flask应用"><a href="#“Hello-World”-Flask应用" class="headerlink" title="“Hello, World” Flask应用"></a>“Hello, World” Flask应用</h2><p><a href="http://flask.pocoo.org/" target="_blank" rel="noopener">Flask网站</a>展示了一个仅有五行代码的简单示例应用程序。 而我会告诉你一个稍微更复杂的例子，它将为你编写更大的应用程序提供一个很好的基础结构。</p>
<p>应用程序是存在于<em>包</em>中的。 在Python中，包含<code>__init__.py</code>文件的子目录被视为一个可导入的包。 当你导入一个包时，<code>__init__.py</code>会执行并定义这个包暴露给外界的属性。</p>
<p>那就创建一个名为<code>app</code>的包来存放整个应用吧。记得切换到<em>microblog</em>目录下，并执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ mkdir app</span><br></pre></td></tr></table></figure></p>
<p>并在其下创建文件<code>__init__.py</code>，输入如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">from app import routes</span><br></pre></td></tr></table></figure></p>
<p>上面的脚本仅仅是从flask中导入的类<code>Flask</code>，并以此类创建了一个应用程序对象。 传递给<code>Flask</code>类的<code>__name__</code>变量是一个Python预定义的变量，它表示当前调用它的模块的名字。当需要加载相关的资源，如我将在<a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-ii-templates" target="_blank" rel="noopener">第二章</a>讲到的模板文件，Flask就使用这个位置作为起点来计算绝对路径。 代码的最后，应用程序导入尚未存在的<code>routes</code>模块。</p>
<p>这段代码，乍一看可能会让人迷惑。</p>
<p>其一，这里有两个实体名为<code>app</code>。 <code>app</code>包由<em>app</em>目录和<code>__init__.py</code>脚本来定义构成，并在<code>from app import routes</code>语句中被引用。 <code>app</code>变量被定义为<code>__init__.py</code>脚本中的<code>Flask</code>类的一个实例，以至于它成为<code>app</code>包的属性。</p>
<p>其二，<code>routes</code>模块是在底部导入的，而不是在脚本的顶部。 最下面的导入是解决<em>循环导入</em>的问题，这是Flask应用程序的常见问题。 你将会看到<code>routes</code>模块需要导入在这个脚本中定义的<code>app</code>变量，因此将<code>routes</code>的导入放在底部可以避免由于这两个文件之间的相互引用而导致的错误。</p>
<p>那么在<code>routes</code>模块中有些什么？ 路由是应用程序实现的不同URL。 在Flask中，应用程序路由的处理逻辑被编写为Python函数，称为<em>视图函数</em>。 视图函数被映射到一个或多个路由URL，以便Flask知道当客户端请求给定的URL时执行什么逻辑。</p>
<p>这是需要写入到<em>app/routes.py</em>中的第一个视图函数的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from app import app</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">@app.route(&apos;/index&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure></p>
<p>这个视图函数简单到只返回一个字符串作为问候用语。 函数上面的两个奇怪的<code>＠app.route</code>行是<em>装饰器</em>，这是Python语言的一个独特功能。 装饰器会修改跟在其后的函数。 装饰器的常见模式是使用它们将函数注册为某些事件的回调函数。 在这种情况下，<code>＠app.route</code>修饰器在作为参数给出的URL和函数之间创建一个关联。 在这个例子中，有两个装饰器，它们将URL <code>/</code>和<code>/index</code>索引关联到这个函数。 这意味着，当Web浏览器请求这两个URL中的任何一个时，Flask将调用该函数并将其返回值作为响应传递回浏览器。这样做是为了在运行这个应用程序的时候会稍微有一点点意义。</p>
<p>要完成应用程序，你需要在定义Flask应用程序实例的顶层（译者注：也就是microblog目录下）创建一个命名为<em>microblog.py</em>的Python脚本。 它仅拥有一个导入应用程序实例的行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from app import app</span><br></pre></td></tr></table></figure></p>
<p>还记得两个<code>app</code>实体吗？ 在这里，你可以在同一句话中看到两者。 Flask应用程序实例被称为<code>app</code>，是<code>app</code>包的成员。<code>from app import app</code>语句从<code>app</code>包导入其成员<code>app</code>变量。 如果你觉得这很混乱，你可以重命名包或者变量。</p>
<p>只要确保所做的操作完全正确，那么你就可以看到如下面的项目结构图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">microblog/</span><br><span class="line">  venv/</span><br><span class="line">  app/</span><br><span class="line">    __init__.py</span><br><span class="line">    routes.py</span><br><span class="line">  microblog.py</span><br></pre></td></tr></table></figure></p>
<p>不管你信不信，这个应用的第一个版本现在完成了！ 但是在运行之前，需要通过设置<code>FLASK_APP</code>环境变量告诉Flask如何导入它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ export FLASK_APP=microblog.py</span><br></pre></td></tr></table></figure></p>
<p>如果你使用Microsoft Windows操作系统，在上面的命令中使用<code>set</code>替换<code>export</code>。</p>
<p>万事俱备，只欠东风！运行如下命令来运行你的第一个Web应用吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ flask run</span><br><span class="line"> * Serving Flask app &quot;microblog&quot;</span><br><span class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure></p>
<p>服务启动后将处于阻塞监听状态，将等待客户端连接。 <code>flask run</code>的输出表明服务器正在运行在IP地址127.0.0.1上，这是本机的回环IP地址。 这个地址很常见，并有一个更简单的名字，你可能已经看过：<em>localhost</em>。 网络服务器监听在指定端口号等待连接。 部署在生产Web服务器上的应用程序通常会在端口443上进行监听，如果不执行加密，则有时会监听80，但启用这些端口需要root权限。 由于此应用程序在开发环境中运行，因此Flask使用自由端口5000。 现在打开您的网络浏览器并在地址栏中输入以下URL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:5000/</span><br></pre></td></tr></table></figure></p>
<p>或者，你也可以使用另一个URL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:5000/index</span><br></pre></td></tr></table></figure></p>
<p>应用程序路由映射执行了吗？ 第一个URL映射到<code>/</code>，而第二个映射到<code>/ index</code>。 这两个路由都与应用程序中唯一的视图函数相关联，所以它们产生相同的输出，即函数返回的字符串。 如果你输入任何其他网址，则会出现错误，因为只有这两个URL被应用程序识别。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4961528-328651893e709b13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hello, World!"></p>
<p>完成演示之后，你可以按下Ctrl-C来停止Web服务。</p>
<p>真是可喜可贺！你已经成功地向成为一名Web开发者的道路上迈出了重要的第一步！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/25/第一章：Hello-world/" data-id="cjmh6hb1a0001lgkxyq7a0fkz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flask-教程/">flask 教程</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/flask-教程/">flask 教程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask-教程/">flask 教程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/flask-教程/" style="font-size: 10px;">flask 教程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/25/第四章：数据库/">第四章：数据库</a>
          </li>
        
          <li>
            <a href="/2018/09/25/第三章：Web表单/">第三章：Web表单</a>
          </li>
        
          <li>
            <a href="/2018/09/25/第二章：模板/">第二章：模板</a>
          </li>
        
          <li>
            <a href="/2018/09/25/第一章：Hello-world/">第一章：Hello world</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>